{
    "info":{
       "packageDescriptionFile":"dub.sdl",
       "authors":[
          "Bradley Chatha",
          "Andrey Zherikov"
       ],
       "license":"MIT",
       "copyright":"Copyright Â© 2021, Bradley Chatha",
       "targetPath":"bin",
       "name":"jcli",
       "description":"A CLI framework library.",
       "dependencies":{
          "jioc":">=0.2.0",
          "silly":"~>1.0.2",
          "asdf":{
             "version":"~>0.5.7",
             "optional":true
          }
       },
       "targetType":"library",
       "configurations":[
          {
             "targetType":"library",
             "versions":[
                "d"
             ],
             "name":"default"
          },
          {
             "targetType":"library",
             "versions":[
                "JCLI_Verbose"
             ],
             "name":"verbose_debug"
          },
          {
             "targetType":"library",
             "versions":[
                "JCLI_Verbose",
                "JCLI_BinderCompilerErrors"
             ],
             "name":"binder_debug"
          }
       ]
    },
    "readmeMarkdown":true,
    "date":"2021-01-28T09:25:30Z",
    "commitID":"c964183d11d1a5d9be43fea9349d758e8ac9cb3e",
    "readme":"<p align=\"center\">\n    <img src=\"https://i.imgur.com/nbQPhO9.png\"/>\n<\/p>\n\n# Overview\n\n![Tests](https://github.com/BradleyChatha/jcli/workflows/Test%20LDC%20x64/badge.svg)\n![Examples](https://github.com/BradleyChatha/jcli/workflows/Test%20Examples/badge.svg)\n\nJCLI is a library to aid in the creation of command line tooling, with an aim of being easy to use, while also allowing\nthe individual parts of the library to be used on their own, aiding more dedicated users in creation of their own CLI core.\n\nAs a firm believer of good documentation, JCLI is completely documented with in-depth explanations where needed. In-browser documentation can be found [here](https://jcli.dpldocs.info/jaster.cli.html).\n\nTested on Windows and Ubuntu 18.04.\n\n1. [Overview](#overview)\n1. [Features](#features)\n1. [\"Quick\" Start/HOWTO](#quick-start)\n    * Basic usage:\n        1. [Creating a default command](#creating-a-default-command)\n        1. [Positional arguments](#positional-arguments)\n        1. [Registering commands](#registering-commands)\n        1. [Running the program](#running-the-program)\n        1. [Named arguments](#named-arguments)\n        1. [Optional arguments](#optional-arguments)\n        1. [Arguments with multiple names](#arguments-with-multiple-names)\n        1. [Named commands](#named-commands)\n        1. [Unparsed Raw Arg List](#unparsed-raw-arg-list)\n\n    * Advanced usage:\n        1. [User Defined argument binding](#user-defined-argument-binding)\n        1. [User Defined argument validation](#user-defined-argument-validation)\n        1. [Per-Argument binding](#per-argument-binding)\n        1. [Dependency Injection](#dependency-injection)\n        1. [Calling a command from another command](#calling-a-command-from-another-command)\n        1. [Configuration](#configuration)\n        1. [Inheritance](#inheritance)\n        1. [Argument groups](#argument-groups)\n        1. [Bash Completion](#bash-completion)\n            1. [Using eval](#using-eval)\n            1. [Using bash-completion](#using-bash-completion)\n        1. [Argument parsing actions](#argument-parsing-actions)\n            1. [CommandArgAction.count](#commandargactioncount)\n        1. [Command Introspection](#command-introspection)\n        1. [Light-weight command parsing](#light-weight-command-parsing)\n        1. [Light-weight command help text](#light-weight-command-help-text)\n        1. [Using a custom sink in CommandLineInterface](#using-a-custom-sink-in-commandlineinterface)\n1. [Using JCLI without Dub](#using-jcli-without-dub)\n1. [Using the amalgamation](#using-the-amalgamation)\n1. [Versions](#versions)\n1. [Contributing](#contributing)\n\n# Features\n\n* Argument parsing:\n\n    * Named and positional arguments.\n\n    * Boolean arguments (flags).\n\n    * Optional arguments using the standard `Nullable` type.\n\n    * User-Defined argument binding (string -> any_type_you_want) - blanket and per-argument.\n\n    * User-Defined argument validation (via UDAs that follow a convention).\n\n    * Pass through unparsed arguments (`./mytool parsed args -- these are unparsed args`).\n\n    * Automatic error messages for missing and malformed arguments.\n\n* Commands:\n\n    * Standard command line format (`./mytool command args --flag=value ...`).\n\n    * Automatic command dispatch.\n\n    * Defined using UDAs, and are automatically discovered.\n\n    * Supports a default command.\n\n    * Supports named commands that allow for multiple words and per-command argument parsing.\n\n    * Opt-in dependency injection via constructor injection.\n\n    * ~~Support for command inheritance~~ (currently broken).\n\n    * Both `struct` and `class` are allowed.\n\n* Help text:\n\n    * Automatically generated with slight ability for customisation.\n\n    * Works for the default command.\n\n    * Works for exact matches for named commands.\n\n    * Works for partial matches for named commands.\n\n    * Arguments can be displayed in organised groups.\n\n* Utilities:\n\n    * Opt-in bash completion support.\n\n    * Coloured, configurable logging.\n\n    * User Input that integrates with User-Defined argument binding and validation.\n\n    * Decent support for writing and parsing ANSI text.\n\n    * Basic but flexible Configuration Providers, used alongside Dependency Injection.\n\n    * An ANSI-enabled text buffer, for easier and efficient control over coloured, non-uniform text output.\n\n    * Shell utilities such as `pushLocation` and `popLocation`, synonymous with Powershell's `Push-Location` and `Pop-Location`.\n\n* Customisable design:\n\n    * All individual parts of this library are intended to be reusable. Allowing you to build your own CLI core using these already-made components, if desired.\n\n# Quick Start\n\n*This is a brief overview, for slightly more in-depth examples please look at the fully-documented [examples](https://github.com/BradleyChatha/jcli/tree/master/examples) folder.*\n\n## Creating a default command\n\nThe default command is the command that is ran when you don't specify any named command. e.g. `mytool 60 20 --some=args` would call the default command if it exists:\n\n```d\n// inside of app.d\nmodule app;\nimport jcli\n\n@CommandDefault(\"The default command.\")\nstruct DefaultCommand\n{\n    int onExecute()\n    {\n        return 0;\n    }\n}\n```\n\nThe `@CommandDefault` is a UDA (User Defined Attribute) where the first parameter is the command's description.\n\nAll commands must define an `onExecute` function, which either returns `void`, or an `int` that will be used as the program's exit/status code.\n\nAs a side note, an initial dub project does not include the `module app;` statement shown in the example above. I've added it as we'll need to directly reference the module in a later section.\n\n## Positional Arguments\n\nTo start off, let's make our default command take a number as a positional arg. If this number is even then return `1`, otherwise return `0`.\n\nPositional arguments are expected to exist in a specific position within the arguments passed to your program.\n\nFor example the command `mytool 60 yoyo true` would have `60` in the 0th position, `yoyo` in the 1st position, and `true` in the 2nd position:\n\n```d\n@CommandDefault(\"The default command.\")\nstruct DefaultCommand\n{\n    @CommandPositionalArg(0, \"number\", \"The number to check.\")\n    int number;\n\n    int onExecute()\n    {\n        return number % 2 == 0 ? 1 : 0;\n    }\n}\n```\n\nWe create the field member `int number;` and decorate it with the `@CommandPositionalArg` UDA to specify it as a positional argument.\n\nThe first parameter is the position this argument should be at, which we define as the 0th position.\n\nThe second parameter is an optional name we can give the parameter, which is shown in the command's help text, but serves no other function.\n\nThe last parameter is simply a description.\n\nAn example of the help text is shown in the [Running your program](#running-your-program) section, which demonstrates why\nyou should provide a name to positional arguments.\n\n## Registering commands\n\nTo use our new command, we just need to register it first:\n\n```d\nimport jcli\n\n// This is still in app.d\nint main(string[] args)\n{\n    auto executor = new CommandLineInterface!(app);\n    const statusCode = executor.parseAndExecute(args);\n\n    UserIO.logInfof(\"Program exited with status code %s\", statusCode);\n\n    return statusCode;\n}\n```\n\nOur main function is defined to return an `int` (status code) while also taking in any arguments passed to us via the `args` parameter.\n\nFirst, we create `executor` which is a `CommandLineInterface` instance. To discover commands, it must know which modules to look in. Remember at the start I told you to write `module app;` at the start of the file? So what we're doing here is passing our module called `app` into `CommandLineInterface`, so that it can find all our commands there.\n\nFor future reference, you can pass any amount of modules into `CommandLineInterface`, not just a single one.\n\nSecond, we call `executor.parseAndExecute(args)`, which returns a status code that we store into the variable `statusCode`. This `parseAndExecute` function will parse the arguments given to it; figure out which command to call; create an instance of that command; fill out the command's argument members, and then finally call the command's `onExecute` function. The rest is pretty self explanatory.\n\nYour app.d file should look something like [this](https://pastebin.com/PhRFtW9G).\n\n## Running the program\n\nFirst, let's have a look at the help text for our default command:\n\n```bash\n$> ./mytool --help\nUsage: mytool.exe DEFAULT <number>\n\nDescription:\n    The default command.\n\nPositional Args:\n    number                       - The number to check.\n```\n\nSo we can see that the help text matches the structure of our `DefaultCommand` struct.\n\nNext, let's try out our command!\n\n```bash\n# Even number\n$> ./mytool 60\nProgram exited with status code 1\n\n# Odd number\n$> ./mytool 59\nProgram exited with status code 0\n\n# No number\n$> ./mytool\nmytool.exe: Missing required arguments <number>\nProgram exited with status code -1\n\n# Too many numbers\n$> ./mytool 1 2\nmytool.exe: too many arguments starting at '2'\nProgram exited with status code -1\n```\n\nExcellent, we can see that with little to no work, our command performs as expected while rejecting invalid use cases.\n\n## Named arguments\n\nNow let's add a mode that will enable reversed output (return `1` for odd number and `0` for even). To do this we should add a named argument called `--mode` that maps directly to an `enum`:\n\n```d\nenum Mode\n{\n    normal,  // Even returns 1. Odd returns 0.\n    reversed // Even returns 0. Odd returns 1.\n}\n\n@CommandDefault(\"The default command.\")\nstruct DefaultCommand\n{\n    @CommandPositionalArg(0, \"number\", \"The number to check.\")\n    int number;\n\n    @CommandNamedArg(\"mode\", \"Which mode to use.\")\n    Mode mode;\n\n    int onExecute()\n    {\n        if(this.mode == Mode.normal)\n            return number % 2 == 0 ? 1 : 0;\n        else\n            return number % 2;\n    }\n}\n```\n\nInside `DefaultCommand` we create a member field called `mode` that is decorated with the `@CommandNamedArg` UDA and has enum type. JCLI knows how to convert an argument value into an enum value.\n\nThe first parameter is the name of the argument, which is actually important this time as this determines what name the user needs to use.\n\nThe second parameter is just the description.\n\nThen inside of `onExecute` we just check what `mode` was set to and do stuff based off of its value.\n\nLet's have a quick look at the help text first, to see the changes being reflected:\n\n```bash\n$> ./mytool --help\nUsage: mytool.exe DEFAULT <number> --mode\n\nDescription:\n    The default command.\n\nPositional Args:\n    number                       - The number to check.\n\nNamed Args:\n    --mode                       - Which mode to use.\n```\n\nAnd now let's test our functionality:\n\n```bash\n# JCLI supports most common argument styles.\n\n# Even (Normal)\n$> mytool 60 --mode normal\nProgram exited with status code 1\n\n# Even (Reversed)\n$> mytool 60 --mode=reversed\nProgram exited with status code 0\n\n# Bad value for mode\n$> mytool 60 --mode non_existing_mode\nmytool.exe: For named argument mode: Mode does not have a member named 'non_existing_mode'\nProgram exited with status code -1\n\n# Can safely assume Odd behaves properly.\n\n# Now, we haven't marked --mode as optional, so...\n$> mytool 60\nmytool.exe: Missing required arguments --mode\nProgram exited with status code -1\n```\n\nWe can see that `--mode` is working as expected, however notice that in the last case, the user isn't allowed to leave out `--mode` since it's not marked as optional.\n\n## Optional Arguments\n\nJCLI supports optional arguments through the standard [Nullable](https://dlang.org/phobos/std_typecons.html#Nullable) type. Note that only Named arguments can be optional for now (technically, Positional arguments can be optional in certain use cases, but it's not supported... yet).\n\nSo to make our `mode` argument optional, we need to make it `Nullable`:\n\n```d\n@CommandDefault(\"The default command.\")\nstruct DefaultCommand\n{\n    @CommandPositionalArg(0, \"number\", \"The number to check.\")\n    int number;\n\n    @CommandNamedArg(\"mode\", \"Which mode to use.\")\n    Nullable!Mode mode;\n\n    int onExecute()\n    {\n        if(this.mode.get(Mode.normal) == Mode.normal)\n            return number % 2 == 0 ? 1 : 0;\n        else\n            return number % 2;\n    }\n}\n```\n\nThe other change we've made is that `onExecute` now uses `mode.get(Mode.normal)` which returns `Mode.normal` if the `--mode` option is not provided.\n\nFirst, let's look at the help text, as it very slightly changes for nullable arguments:\n\n```bash\n$> ./mytool --help\nUsage: mytool.exe DEFAULT <number> [--mode]\n\nDescription:\n    The default command.\n\nPositional Args:\n    number                       - The number to check.\n\nNamed Args:\n    --mode                       - Which mode to use.\n```\n\nNotice the \"Usage:\" line. `--mode` has now become `[--mode]` to indicate it is optional.\n\nSo now let's test that the argument is now optional:\n\n```bash\n# Even (implicitly Normal)\n$> ./mytool 60\nProgram exited with status code 1\n\n# Even (Reversed)\n$> ./mytool 60 --mode reversed\nProgram exited with status code 0\n```\n\n## Arguments with multiple names\n\nWhile `--mode` is nice and descriptive, it'd be nice if we could also refer to it via `-m` wouldn't it?\n\nHere is where the very simple concept of \"patterns\" comes into play. At the moment, and honestly for the foreseeable future, patterns are just strings with a pipe ('|') between each different value:\n\n```d\n@CommandDefault(\"The default command.\")\nstruct DefaultCommand\n{\n    @CommandNamedArg(\"mode|m\", \"Which mode to use.\")\n    Nullable!Mode mode;\n\n    // omitted as it's unchanged...\n}\n```\n\nAll we've done is changed `@CommandNamedArg`'s name from `\"mode\"` to `\"mode|m\"`, which basically means that we can use *either* `--mode` or `-m` to set the mode.\n\nYou can have as many values within a pattern as you want. Named Arguments cannot have whitespace within their patterns though.\n\nLet's do a quick test as usual:\n\n```bash\n$> ./mytool 60 -m normal\nProgram exited with status code 1\n\n# JCLI even supports this weird syntax shorthand arguments sometimes use.\n$> ./mytool 60 -mreversed\nProgram exited with status code 0\n\n# And here's the help text\n$> ./mytool --help\nUsage: mytool.exe DEFAULT <number> [--mode|-m]\n\nDescription:\n    The default command.\n\nPositional Args:\n    number                       - The number to check.\n\nNamed Args:\n    --mode,-m                    - Which mode to use.\n```\n\n## Named Commands\n\nNamed commands are commands that... have a name. For example `git commit`; `git remote add`; `dub init`, etc. are all named commands.\n\nIt's really easy to make a named command. Let's change our default command into a named command:\n\n```d\n// Renamed from DefaultCommand\n@Command(\"assert|a|is even\", \"Asserts that a number is even.\")\nstruct AssertCommand\n{\n    // ...\n}\n```\n\nBasically, we change `@CommandDefault` to `@Command`, then we just pass a pattern (yes, commands can have multiple names!) as the first parameter for the `@Command` UDA, and move the description into the second parameter.\n\nCommand patterns can have spaces in them, to allow for a multi-word, fluent interface for your tool.\n\nAs a bit of a difference, let's test the code first:\n\n```bash\n# We have to specify a name now. JCLI will offer suggestions!\n$> ./mytool 60\nmytool.exe: Unknown command '60'.\nDid you mean:\n    assert                       - Asserts that a number is even.\n\n# Passing cases (all producing the same output)\n$> ./mytool assert 60\n$> ./mytool a 60\n$> ./mytool is even 60\nProgram exited with status code 1\n```\n\nJCLI has \"smart\" help text when it comes to displaying named commands. Observe here that JCLI is careful to only display one of the possible\nnames for commands that may have multiple names:\n\n```bash\n# JCLI will always display the first name of each commands' pattern.\n$> ./mytool --help\nAvailable commands:\n    assert                       - Asserts that a number is even.\n```\n\nThe other feature of this help text is that JCLI has support for partial command matches:\n\n**FUTURE ME I NEED TO FIX THIS BELOW EXAMPLE** - It should display \"is even\" instead of \"assert\" for the last set of help text.\nI find it funny that the bash completion code knows how to do this, but the help text generator doesn't.\n\n```bash\n# So let's first start with a tool that has two commands.\n$> ./mytool --help\nAvailable commands:\n    assert                       - Asserts that a number is even.\n    do a                         - Does A\n\n# If we have a partial match to a command, then JCLI will filter the results down.\n$> ./mytool do\nmytool.exe: Unknown command 'do'.\nDid you mean:\n    do a                         - Does A\n\n# If the command has multiple names, then JCLI is careful to use the correct name for the partial match.\n# Remember that \"assert\" is also \"is even\".\n$> ./mytool is --help\nAvailable commands:\n    assert                       - Asserts that a number is even.\n```\n\n## User Defined argument binding\n\nJCLI has support for users specifying their own functions for converting an argument's string value into the final value passed into the command instance.\n\nIn fact, all of JCLI's built in arg binders use this system, they're just implicitly included by JCLI.\n\nWhile I won't go over them directly, [here's](https://github.com/BradleyChatha/jcli/blob/master/source/jaster/cli/binder.d#L37) the documentation for lookup rules regarding binders, for those of you who are interested.\n\nLet's recreate the `cat` command, which takes a filepath and then outputs the contents of that file.\n\nInstead of asking JCLI for just a string though, let's create an arg binder that will construct a `File` (from [std.stdio](https://dlang.org/library/std/stdio/file.html)) from the string, so our command doesn't have to do any file loading by itself.\n\nFirst, we need to create the arg binder:\n\n```d\n// app.d still\nimport std.stdio : File;\nimport jcli      : Result;\n\n@ArgBinderFunc\nResult!File fileBinder(string arg)\n{\n    import std.file : exists;\n\n    // Alternatively: Result!File.failureIf(!arg.exists, File(arg, \"r\"), \"File does not exist: \"~arg)\n    return (arg.exists)\n    ? Result!File.success(File(arg, \"r\"))\n    : Result!File.failure(\"File does not exist: \"~arg);\n}\n```\n\nFirst of all we import `File` from the `std.stdio` module and `Result` from `jcli`.\n\nSecond, we create a function, decorated with `@ArgBinderFunc`, that follow a specific convention for its signature:\n\n```d\n@ArgBinderFunc\nResult!<OutputType> <anyNameItDoesntMatter>(string arg);\n```\n\nThe return type is a `Result`, whose `<OutputType>` is the type of the value that the binder sets the argument to, which is a `File` in our case.\n\nThe `arg` parameter is the raw string provided by the user, for whichever argument we're binding from.\n\nFinally, we check if the file exists, and if it does we return a `Result!File.success` with a `File` opened in read-only mode. If it doesn't exist then we\nreturn a `Result!File.failure` alongside a user-friendly error message.\n\nArg binders need to be marked with the `@ArgBinderFunc` UDA so that the `CommandLineInterface` class can discover them. Talking about `CommandLineInterface`, it'll automatically discover any arg binder from the modules you tell it about, just like it does with commands.\n\nLet's now create our new command:\n\n```d\n@Command(\"cat\", \"Displays the contents of a file.\")\nstruct CatCommand\n{\n    @CommandPositionalArg(0, \"filePath\", \"The path to the file to display.\")\n    File file;\n\n    void onExecute()\n    {\n        import std.stdio : writeln;\n\n        foreach(lineInFile; this.file.byLine())\n            writeln(lineInFile);\n    }\n}\n```\n\nThe most important thing of note here is, notice how the `file` variable has the type `File`, and recall that our arg binder's return type also has the type `Result!File`? This allows the arg binder to know that it has a function to convert the user's provided string into a `File` for us.\n\nOur `onExecute` function is nothing overly special, it just displays the file line by line.\n\nTest time. Let's make it show the contents of our `dub.json` file, which is within the root of our project:\n\n```bash\n$> ./mytool cat ./dub.json\n{\n    \"authors\": [\n            \"Sealab\"\n    ],\n    \"copyright\": \"Copyright â¬Â® 2020, Sealab\",\n    \"dependencies\": {\n            \"jcli\": \"~>0.10.0\"\n    },\n    \"description\": \"A minimal D application.\",\n    \"license\": \"proprietary\",\n    \"name\": \"mytool\"\n}\nProgram exited with status code 0\n\n# And just for good measure, let's see what happens if the file doesn't exist\n$> ./mytool cat non-existing-file\nmytool.exe: For positional arg 0(filePath): File does not exist: non-existing-file\n```\n\nVery simple. Very useful.\n\n## User Defined argument validation\n\nIt's cool and all being able to very easily create arg binders, but sometimes commands will need validation logic involved.\n\nFor example, some commands might only want files with a `.json` extention, while others may not care about extentions. So putting this logic into the arg binder itself isn't overly wise.\n\nSome arguments may need validation on the pre-arg-binded string, whereas others may need validation on the post-arg-binded value. Some may need both!\n\nJCLI handles all of this via argument validators.\n\nLet's start off with the first example, making sure the user only passes in files with a `.json` extention, and apply it to our `cat` command. Code first, explanation after:\n\n```d\n@ArgValidator\nstruct HasExtention\n{\n    string wantedExtention;\n\n    Result!void onPreValidate(string arg)\n    {\n        import std.algorithm : endsWith;\n\n        // If the condition is true, return a failure result with a message, otherwise return a success result.\n        return Result!void.failureIf(\n            !arg.endsWith(this.wantedExtention), \n            \"Expected file to have extention of \"~this.wantedExtention\n        );\n    }\n}\n\n@Command(\"cat\", \"Displays the contents of a file.\")\nstruct CatCommand\n{\n    @CommandPositionalArg(0, \"filePath\", \"The path to the file to display.\")\n    @HasExtention(\".json\")\n    File file;\n\n    // omitted...\n}\n```\n\nTo start, we create a struct called `HasExtention`, we decorate it with `@ArgValidator`, and we give it a field member called `string wantedExtention;`.\n\nBefore I continue, I want to explicitly state that this validator wants to perform validation on the raw string that the user provides (pre-arg-binded) and *not* on the final value (post-arg-binded). This is referred to as \"Pre Validation\". So on that note...\n\nNext, and most importantly, we define a function that specifically called `onPreValidate` that follows the following convention:\n\n```d\nResult!void onPreValidate(string arg);\n```\n\nThis is the function that performs the actual validation (in this case, \"Pre\" validation).\n\nIt returns `Result!void.success()` if there are no validation errors, otherwise it returns `Result!void.failure()` and optionally provides an error string as a user-friendly error (one is automatically generated otherwise).\n\nThe return type is a `Result!void`, so a result that doesn't contain a value, but still states whether there was a failure or a success.\n\nThe first parameter to our function is the raw string that the user has provided us.\n\nSo for our `HasExtention` validator, all we do is check if the user's file path ends with `this.wantedExtention`, which we set the value of later.\n\nNow, inside `CatCommand` all we've done is attach our `HasExtention` struct as a UDA (and if you're not familiar with D, congrats, you just made your first UDA!). JCLI will automatically detect that `@HasExtention` is a validator because it is decorated with `@ArgValidator`.\n\nBecause D is wonderful, it will automatically generate a constructor for us where the first parameter sets the `wantedExtention` member. So `@HasExtention(\".json\")` will set the extention we want to `\".json\"`.\n\nAnd that's literally all there is to it, let's test:\n\n```bash\n# Passing\n$> ./mytool cat ./dub.json\n[contents of dub.json since validation was a success]\nProgram exited with status code 0\n\n# Failing\n$> ./mytool cat ./.gitignore\nmytool.exe: For positional arg 0(filePath): Expected file to have extention of .json\nProgram exited with status code -1\n```\n\nThe other type of validation is post-arg-binded validation, which performs validation on the final value provided by an arg binder.\n\nLet's make a validator that ensures that the file is under a certain size:\n\n```d\n@ArgValidator\nstruct MaxSize\n{\n    ulong maxSize;\n\n    Result!void onValidate(File file)\n    {\n        return Result!void.failureIf(\n            file.size() > this.maxSize,\n            \"File is too large.\"\n        );\n    }\n}\n\n@Command(\"cat\", \"Displays the contents of a file.\")\nstruct CatCommand\n{\n    @CommandPositionalArg(0, \"filePath\", \"The path to the file to display.\")\n    @HasExtention(\".json\")\n    @MaxSize(2)\n    File file;\n\n    // omitted...\n}\n```\n\nThe convention for post-arg-binded validation is almost exactly the same as pre-arg-binded validation, it also functions in exactly the same way:\n\n```d\nResult!void onValidate(<TYPE_OF_VALUE_TO_VALIDATE> value);\n```\n\nThe only difference is that the first parameter isn't a `string`, but instead the type of value that this validator will work with.\n\nValidators can have different overloads of this function if required. You can even make it a template. JCLI is fine with any of that.\n\nWe've set the max size to something really small, so we can easily test that it works:\n\n```bash\n$> ./mytool cat ./dub.json\nmytool.exe: For positional arg 0(filePath): File is too large.\nProgram exited with status code -1\n```\n\nExcellent. We have an issue however where this is all a bit... cumbersome, right?\n\nWell, for small one-off validation tasks like this, we can use the two built-in validators `@PreValidate` and `@PostValidate`.\n\nThis is what the above example would look like using these two validators:\n\n```d\n@Command(\"cat\", \"Displays the contents of a file.\")\nstruct CatCommand\n{\n    @CommandPositionalArg(0, \"filePath\", \"The path to the file to display.\")\n    @PreValidate!(str => Result!void.failureIf(!str.endsWith(\".json\"), \"Expected file to end with .json.\"))\n    @PostValidate!(file => Result!void.failureIf(file.size() > 2, \"File is larger than 2 bytes.\"))\n    File file;\n\n    // omitted...\n}\n```\n\nSo now we've moved the logic of `HasExtention` into a lamba inside `@PreValidate`, and the logic of `MaxSize` into `PostValidate`.\n\nYou can of course also pass already-made functions instead of lambdas, if that's more your thing.\n\nThe results are exactly the same as before, so they will be omitted.\n\n## Per-argument binding\n\nThere is seemingly a fatal flaw with the arg binding system.\n\nImagine we had a `copy` command that copies the contents of a file into another file:\n\n```d\n@Command(\"copy\", \"Copies a file\")\nstruct CopyCommand\n{\n    @CommandPositionalArg(0, \"source\", \"The source file.\")\n    File source;\n\n    @CommandPositionalArg(1, \"destination\", \"The destination file.\")\n    File destination;\n\n    void onExecute()\n    {\n        foreach(line; source.byLine)\n            destination.writeln(line);\n    }\n}\n```\n\nThe issue here is that `source` needs to be opened in read-only mode(`r`), however `destination` needs be written in truncate/write mode(`w`).\n\nIf we were to create a normal `@ArgBinderFunc`, we wouldn't be able to tell it the difference between the two files since we're limited in the amount\nof information that is passed to an arg binder.\n\nWhat we need is a way to specify the binding behavior on a per-argument basis.\n\nWhile you *could* do a hackish thing such as creating two separate file types (`ReadOnlyFile` and `WriteFile`) then making arg binders for them, there's actually\na much easier solution - `@ArgBindWith`:\n\n```d\nimport std.stdio : File;\n\nResult!File openReadOnly(string arg)\n{\n    import std.file : exists;\n\n    return (arg.exists)\n    ? Result!File.success(File(arg, \"r\"))\n    : Result!File.failure(\"The file doesn't exist: \"~arg);\n}\n\n@Command(\"copy\", \"Copies a file\")\nstruct CopyCommand\n{\n    @CommandPositionalArg(0, \"source\", \"The source file.\")\n    @ArgBindWith!openReadOnly\n    File source;\n\n    @CommandPositionalArg(1, \"destination\", \"The destination file.\")\n    @ArgBindWith!(arg => Result!File.success(File(arg, \"w\")))\n    File destination;\n\n    void onExecute()\n    {\n        foreach(line; source.byLine)\n            destination.writeln(line);\n    }\n}\n```\n\nTo start off, we create the fairly self-explanatory `openReadOnly` function which looks exactly like an `@ArgBinderFunc`, except it doesn't have the UDA attached to it.\n\nNext, we attach `@ArgBindWith!openReadOnly` onto our `source` argument. This tells JCLI to use our `openReadOnly` function as this argument's binder.\n\nFinally, we attach `@ArgBindWith!(/*lambda*/)` onto our `destination` argument, for the same reasons as above. A lambda is used here for demonstration purposes.\n\nAnd just like that we have now solved overcome our initial issue of \"how to I customise binding for arguments of the same type?\" in a simple, sane manner.\n\nI'd like to mention that this feature works alongside the usual arg binding behavior. In other words, you can define an `@ArgBinderFunc` for a type which will\nserve as the default method for binding, but then for those awkward, one-off cases you can use `@ArgBindWith` to specify a different binding behavior on a per-argument\nbasis.\n\n## Unparsed Raw Arg List\n\nIn some cases you might want to stop parsing arguments and just get them as raw strings. JCLI supports this use case by allowing raw arguments to appear after a long double-dash (`--`) parameter in the command line: `./mytool args to parse -- args to pass as is`.\n\nCommands can access the raw arg list like so:\n\n```d\n@Command(\"echo\", \"Echos the raw arg list.\")\nstruct EchoCommand\n{\n    @CommandRawListArg\n    string[] rawArgs;\n\n    void onExecute()\n    {\n        import std.stdio;\n        foreach(arg; this.rawArgs)\n            writeln(arg);\n    }\n}\n```\n\nSimply make a field of type `string[]`, then mark it with `@CommandRawListArg`, and then voila:\n\n```bash\n$> ./mytool echo -- Hello world, please be kind.\nHello\nworld,\nplease\nbe\nkind.\nProgram exited with status code 0\n```\n\n## Dependency Injection\n\nCommands in JCLI actually live inside an IOC container (henceforth 'Service Provider'), provided by my other library called [jioc](https://github.com/BradleyChatha/jioc).\n\nBy default, JCLI will construct the Service Provider on its own and register some internal services to it.\n\nHowever JCLI will also allow you to provide it with an already-made Service Provider so that you can inject your own services into your commands via\nconstructor injection.\n\nTo start off, you'll need to run `dub add jioc`, as well as `import jaster.ioc`:\n\n```d\nimport jaster.ioc;\n\nint main(string[] args)\n{\n    ServiceInfo[] services;\n    // We'll leave the array empty for now, as different sections will go over some specifics.\n\n    auto provider = new ServiceProvider(services);\n    auto executor = new CommandLineInterface!(app)(provider);\n    // same as before from here...\n}\n```\n\nTo start off, build up an array of `ServiceInfo`. If you want to learn about making your own services, for now you'll need\nto take a look at the [example](https://github.com/BradleyChatha/jcli/tree/master/examples/05-dependency-injection/source) code, and maybe also some of JIOC's \n[code](https://github.com/BradleyChatha/jioc). I'll get around to better docs *eventually*.\n\nAnyway, that's basically it to start off with. Any services you provide a `ServiceInfo` for can now be obtained via constructor injection. The section below will\nshow off an example.\n\n## Calling a command from another command\n\nIt can be useful to call different commands from within another command, so JCLI sort of has you covered here.\n\nJCLI, via dependency injection, provides the `ICommandLineInterface` service which exposes the `parseAndExecute` function that you already know and love.\n\nSo, following on from the code in the [Dependency Injection](#dependency-injection) section, we'll inject an `ICommandLineInterface` into a new command, whose\npurpose is to call the `echo` command (from the [Raw Arg List](#unparsed-raw-arg-list) section) with a predefined set of arguments:\n\n```d\nint main(string[] args)\n{\n    ServiceInfo[] services;\n    services.addCommandLineInterfaceService();\n\n    // omitted...\n}\n\n@Command(\"say hello\", \"Says hello!\")\nstruct SayHelloCommand\n{\n    private ICommandLineInterface _cli;\n\n    this(ICommandLineInterface cli)\n    {\n        assert(cli !is null);\n        this._cli = cli;\n    }\n\n    int onExecute()\n    {\n        return this._cli.parseAndExecute([\"echo\", \"--\", \"Hello!\"], IgnoreFirstArg.no);\n    }\n}\n```\n\nWithin the main function we first call `services.addCommandLineInterfaceService`, which is provided by JCLI to create the `ServiceInfo` that describes\n`ICommandLineInterface`. i.e. This tells the `ServiceProvider` on how to create a solid instance of `ICommandLineInterface` when we need one.\n\nInside of our new command, with have our constructor (`this(ICommandLineInterface)`) that is asking for an `ICommandLineInterface`.\n\nSo, when JCLI is constructing a command instance it does so via JIOC's `Injector.construct` function.\n\nThe way `Injector.construct` works is: it looks at every parameter of the command's constructor (if it has one); any type that is a class or interface, it'll\nattempt to retrieve via a `ServiceProvider`; if it was successful, and instance of that class or interface is passed as that constructor parameter, otherwise `null`\nis passed through.\n\nIn other words, by asking for an `ICommandLineInterface` within our constructor, we're just telling JCLI to fetch that service from the Service Provider and pass it\nthrough via our constructor, which from there we'll store the reference. We do a null check assert just in case our service doesn't exist within the Service Provider.\n\nAfter that, when we're executing our new command we essentially generate a call similar to `./mytool echo -- Hello!`, except programmatically, making sure we\nforward the status code.\n\nA note about `parseAndExecute`'s second parameter - the `args` from the main function will usually have the program's name as the 0th element, which we generally\ndon't care about so `parseAndExecute` will skip it by default.\n\nHowever, when we want to manually pass in arguments we *don't* want it to skip over the first element, which is what the second parameter is telling it to do.\n\n## Configuration\n\nMany tools require persistent configuration, which is an easy yet tedious task to setup, so JCLI provides a rather basic yet useable configuration interface.\n\nThe configuration provided by JCLI isn't meant to be overly advanced, it's more just a \"get me a working config file ASAP\" useful for smaller applications/prototypes,\nwho don't really need something too fancy.\n\nConfiguration is provided via Dependency Injection, using the `IConfig` interface.\n\nThere are two implementations of `IConfig` provided by JCLI currently: an in-memory config, and a file config. Both of these implementations are `Adaptable` - as in their\nserialisation logic is provided by an external library, bridged into JCLI via an adapter.\n\nJCLI currently only has one built-in adapter which is for [asdf](https://github.com/libmir/asdf), a fast and relatively robust JSON serialisation library.\n\nWriting adapters is very easy to the point where, after all this talk about certain things following a \"convention\", you should be able to pick it up pretty quickly\nby looking at the [asdf adapter](https://github.com/BradleyChatha/jcli/blob/master/source/jaster/cli/adapters/config/asdf.d) itself.\n\nSo to put it all together, if you want a file config that uses asdf for serialisation (which means you also get to use all the UDAs and other idiosyncrasies of\nwhichever library you use), then you can go with an `AdaptableFileConfig` paired with the `AsdfConfigAdapter`.\n\nSo, after all that mumbo jumbo, let's see how to use actually use it inside of a program. Before you being, you must run `dub add asdf` otherwise the asdf adapter\nwon't be available:\n\n```d\nstruct Config\n{\n    string file;\n    int counter;\n    bool destroyComputerOnError;\n}\n\nint main(string[] args)\n{\n    ServiceInfo[] services;\n    services.addFileConfig!(Config, AsdfConfigAdapter)(\"./config.json\");\n\n    /// omitted.\n}\n\n@Command(\"seed config\", \"Seeds the config file with some odd data.\")\nstruct SeedConfigCommand\n{\n    IConfig!Config _config;\n\n    this(IConfig!Config config)\n    {\n        assert(config !is null);\n        this._config = config;\n    }\n\n    void onExecute()\n    {\n        // A shortcut for this is `editAndSave`\n        WasExceptionThrown yesOrNo = this._config.edit(\n            // Don't forget the `scope ref`\n            (scope ref config)\n            {\n                config.file = \"Andy's dirty secret.txt\";\n                config.counter = 200;\n                config.destroyComputerOnError = true;\n            },\n            RollbackOnFailure.yes,\n            SaveOnSuccess.yes\n        );\n        assert(yesOrNo == WasExceptionThrown.no);\n    }\n}\n\n@Command(\"print config\", \"Prints the config to the screen.\")\nstruct PrintConfigCommand\n{\n    IConfig!Config _config;\n\n    this(IConfig!Config config)\n    {\n        assert(config !is null);\n        this._config = config;\n    }\n\n    void onExecute()\n    {\n        import std.stdio;\n        writeln(this._config.value);\n    }\n}\n```\n\nQuite a big chunk of code this time, but when broken down it's pretty simple.\n\nWe first define our `Config` struct, which is just your average POD struct with some data we want to persist.\n\nThen we use the `services.addFileConfig` function to create a `ServiceInfo` that describes an `AdaptableFileConfig`.\n\nThe first template parameter is the user-defined type to store into the file, so `Config` in this case.\n\nThe second template parameter is the adapter to use, which is the `AsdfConfigAdapter`.\n\nThe first runtime parameter is the path to where the file should be stored.\n\nSo we are using asdf to store/retrieve our `Config` from the file `\"./config.json\"`, in essence.\n\nWe can access this service from our commands by requesting an `IConfig!Config`.\n\nOver inside of the `SeedConfigCommand` struct, we have an instance of `IConfig!Config` injected, and then inside of `onExecute` we do something\na bit more peculiar.\n\nThe `IConfig.edit` function is used here, as I want to demonstrate the handful of capabilities that `IConfig` supports. As the comment says, there's\na shortcut function for this particular usage called `editAndSave`.\n\nThe first parameter is a delegate (lambda) that is given a shallow copy of the configuration's value by reference. All this delegate needs to do is\npopulate the configuration value with whatever it wants to set it to, by whatever means to get the data.\n\nThe second parameter is a flag called `RollbackOnFailure`. As the name implies, if the delegate in the first parameter throws an exception then the\n`IConfig` will attempt to rollback any changes. Please see [this comment](https://jcli.dpldocs.info/jaster.cli.config.IConfig.edit.html) on it works exactly.\n\nThe third and final parameter is a flag called `SaveOnSuccess`, which literally does at it says on the tin. If the delegate was successful, then call\n`IConfig.save` to save any changes.\n\nFinally with this `onExecute`, we just make sure that the return value was `WasExceptionThrown.no`, which explains itself.\n\nAlternatively you can just set `IConfig.value` to something, and then call `IConfig.save`. The `IConfig.edit` function was just supposed to be a helper\naround things.\n\nWe're now onto the final part of this code which is the `PrintConfigCommand`.\n\nLiterally all it does it ask for the config to be injected, retrieves its value via `IConfig.value`, and then prints it to the screen\n(D's `writeln` automatically pretty prints structs).\n\nAs I said, JCLI's built-in configuration isn't terribly fancy, and offloads the majority of the work onto third party code. But it gets the job\ndone when you just want something up quick and easy.\n\n## Inheritance\n\n**As of v0.12.0 inheritance is currently in a broken state, please see issue [#44](https://github.com/BradleyChatha/jcli/issues/44) for a description**\n**of the issue, as well as a mitigation suggestion.**\n\nJCLI supports command inheritance.\n\nThe only rules with inheritance are:\n\n* Only concrete classes can be marked with `@Command`.\n\n* Concrete classes must have `onExecute` defined, either by a base class or directly.\n\nOther than that, go wild. Every argument marked with `@CommandNamedArg` and `@CommandPostionalArg` will be discovered within the inheritance tree for a command,\nand they will all be populated as expected:\n\n```d\nabstract class CommandBase\n{\n    @CommandNamedArg(\"verbose|v\", \"Show verbose information.\")\n    Nullable!bool verbose;\n\n    // This isn't recognised my JCLI, it's just a function all our\n    // child classes should call as an arbitrary design choice.\n    final void onPreExecute()\n    {\n        import std.stdio;\n\n        if(this.verbose.get(false))\n            writeln(\"Running in verbose mode!\");\n    }\n\n    // Force our child classes to implement the function JCLI recognises.\n    abstract void onExecute();\n}\n\n@Command(\"verbose say hello\", \"Says hello!... but only when you define the verbose flag.\")\nfinal class MyCommand : CommandBase\n{\n    override void onExecute()\n    {\n        import std.stdio;\n        super.onPreExecute();\n\n        if(super.verbose.get(false))\n            writeln(\"Hello!\");\n    }\n}\n```\n\nNothing here is overly new, and it should make sense to you if you've gotten this far down:\n\n```bash\n# Without flag\n$> ./mytool verbose say hello\nProgram exited with status code 0\n\n# With flag\n$> ./mytool verbose say hello --verbose\nRunning in verbose mode!\nHello!\nProgram exited with status code 0\n```\n\nTo summarize, JCLI supports inheritance within commands, and it should for the most part function as you expect. The rest is down\nto your own design.\n\n## Argument groups\n\nSome applications will find it useful to group their arguments together inside of their help text, for example:\n\n```bash\n$> ./mytool command -h\nUsage: mytool.exe command <arg1> <arg2> <output> --test-flag [--verbose|-v] [--log|-l] [--config|-c]\n\nDescription:\n    This is a command that is totally super complicated.\n\nPositional Args:\n    arg1                         - This is a generic argument that isn't grouped anywhere\n    arg2                         - This is a generic argument that isn't grouped anywhere\n\nNamed Args:\n    --test-flag                  - Test flag, please ignore.\n\nDebug:\n    Arguments related to debugging.\n\n    --verbose,-v                 - Enables verbose logging.\n    --log,-l                     - Specifies a log file to direct output to.\n\nI/O:\n    Arguments related to I/O.\n\n    output                       - Where to place the output.\n    --config,-c                  - Specifies the config file to use.\n```\n\nThis can be achieved by using the `@CommandArgGroup` UDA - this is how to produce the above help text:\n\n```d\n@Command(\"command\", \"This is a command that is totally super complicated.\")\nstruct ComplexCommand\n{\n    @CommandPositionalArg(0, \"arg1\", \"This is a generic argument that isn't grouped anywhere\")\n    int a;\n    @CommandPositionalArg(1, \"arg2\", \"This is a generic argument that isn't grouped anywhere\")\n    int b;\n\n    @CommandNamedArg(\"test-flag\", \"Test flag, please ignore.\")\n    bool flag;\n\n    @CommandArgGroup(\"Debug\", \"Arguments related to debugging.\")\n    {\n        @CommandNamedArg(\"verbose|v\", \"Enables verbose logging.\")\n        Nullable!bool verbose;\n\n        @CommandNamedArg(\"log|l\", \"Specifies a log file to direct output to.\")\n        Nullable!string log;\n    }\n\n    @CommandArgGroup(\"I/O\", \"Arguments related to I/O.\")\n    {\n        @CommandPositionalArg(2, \"output\", \"Where to place the output.\")\n        string output;\n\n        @CommandNamedArg(\"config|c\", \"Specifies the config file to use.\")\n        Nullable!string config;\n    }\n\n    void onExecute(){}\n}\n```\n\nCurrently, the order of groups is based on their order in the source code.\n\n## Bash Completion\n\nJCLI's bash completion is opt-in, so first you'll need to enable it inside of `CommandLineSettings`:\n\n```d\nimport jcli\n\nint main(string[] args)\n{\n    CommandLineSettings settings;\n    settings.bashCompletion = true;\n\n    auto cli = new CommandLineInterface!()(settings /*, services - if you were using Dependency Injection*/);\n    return cli.parseAndExecute(args);\n}\n```\n\nThis will enable two special commands - `__jcli:complete`, and `__jcli:bash_complete_script`.\n\nThe first command is used to perform the actual logic behind bash completion, and generally you don't need to call it directly.\n\nThe second command however will output a bash script that can enable bash completion for your executable.\n\nFrom this point on, it is mostly down to how your system is setup, will be listed below.\n\n### Using eval\n\nBy using the `eval` command, you can enable bash completion for the **current** shell session.\n\n```bash\n$> eval \"$(./myTool __jcli:bash_complete_script)\"\n\n# Provide command names.\n$> ./myTool [TAB]\nansi    benchmark   build\n\n# Filter commands by current input.\n$> ./myTool b[TAB]\nbenchmark build\n\n# Provide argument names.\n$> ./myTool benchmark -[TAB]\n--runs --verbose\n\n# Smartly removes suggestions for arguments already in use.\n$> ./myTool benchmark --runs 20 -[TAB]\n--verbose\n```\n\n### Using bash-completion\n\nIf your system uses bash-completion, then the following command will add completion for your tool into every shell session:\n\n```bash\n# NOTE: The actual path may be different on your system/distro.\n$> myTool __jcli:bash_complete_script > /etc/.bash_completion.d/myTool\n```\n\n## Argument parsing actions\n\nThere are specific cases where arguments may need to be parsed in a different manner. You can customise parsing behavior on a per-argument basis by attaching any enum value from the `CommandArgAction` enum.\n\n### CommandArgAction.count\n\nBy attaching `@(CommandArgAction.count)` onto a named argument, the argument's behavior will change in the following ways:\n\n* Every time the argument is defined within the command's parameters, the value of the argument is incremented.\n\n* The argument becomes optional by default.\n\n* No explicit value can be given to the argument.\n\n* Arg binding and arg validation are not performed.\n\n* Special syntax `-aaaa` (where 'a' is the name of the arg) is supported.\n\nYou can use any type that supports `opUnary!\"++\"`, even custom types.\n\nHere's an example command:\n\n```d\n@CommandDefault(\"Outputs the value of '-a'.\")\nstruct SumCommand\n{\n    @CommandNamedArg(\"a\")\n    @(CommandArgAction.count)\n    int arg;\n\n    void onExecute()\n    {\n        writeln(this.arg);\n    }\n}\n```\n\nWith an example usage:\n\n```bash\n$> ./myTool -a -a\n2\n\n$> ./myTool -aaaaa\n5\n\n$> ./myTool\n0\n```\n\n## Command Introspection\n\nIn certain cases there may be a need for being able to gather and inspect the data of a command and its arguments, ideally in the same way\nJCLI is able to.\n\nJCLI exposes this via the `jaster.cli.infogen` package, which gathers all the JCLI-relevant details about a command and all of its recognised arguments.\n\nThis information is available at compile-time, allowing for the usual meta-programming shenanigans that D allows. This is useful for those that want to build\ntheir own functionality on top of the several parts JCLI provides.\n\nOur example will simply be an empty command with a few arguments we'd like to get information of:\n\n```d\nimport std, jaster.cli;\n\n@Command(\"name\", \"description\")\nstruct MyCommand\n{\n    @CommandNamedArg(\"v|verbose\", \"Toggle verbose output.\")\n    Nullable!bool verbose;\n\n    @CommandNamedArg(\"l\", \"Verbose level counter.\")\n    @(CommandArgAction.count)\n    uint lCount;\n\n    @CommandPositionalArg(0, \"arg1\", \"The first argument to do stuff with.\")\n    string arg1;\n\n    // No definition of 'onExecute' is required for this use-case.\n}\n\n// Via the `getCommandInfoFor` template, we can gather all the JCLI-relevant information we want.\n// We do also have to pass in an instantiation of `ArgBinder`, but it's an unfortunate yet minor design limitation.\nenum Info = getCommandInfoFor!(MyCommand, ArgBinder!());\n\nvoid main()\n{\n    writeln(\"[Command Info]\");\n    writeln(\"Pattern     = \", Info.pattern);\n    writeln(\"Description = \", Info.description);\n    writeln();\n\n    void displayArg(ArgInfoT)(ArgInfoT argInfo)\n    {\n        writefln(\"[Argument Info - %s]\", ArgInfoT.stringof);\n        writeln(\"Identifier  = \", argInfo.identifier);\n        writeln(\"UDA         = \", argInfo.uda);\n        writeln(\"Action      = \", argInfo.action);\n        writeln(\"Group       = \", argInfo.group);\n        writeln(\"Existence   = \", argInfo.existence);\n        writeln(\"ParseScheme = \", argInfo.parseScheme);\n        writeln();\n    }\n\n    foreach(arg; Info.namedArgs) displayArg(arg);\n    foreach(arg; Info.positionalArgs) displayArg(arg);\n\n    if(Info.rawListArg.isNull)\n        writeln(\"[No Raw Arg List]\\n\");\n    else\n        displayArg(Info.rawListArg.get);\n\n    // If needed, you can still get access to the argument's symbol.\n    alias Symbol = __traits(getMember, MyCommand, Info.namedArgs[0].identifier);\n    writeln(\"Arg0Nullable = \", isInstanceOf!(Nullable, typeof(Symbol)));\n}\n```\n\nWith the output of:\n\n```bash\n[Command Info]\nPattern     = Pattern(\"name\")\nDescription = description\n\n[Argument Info - ArgumentInfo!(CommandNamedArg, MyCommand)]\nIdentifier  = verbose\nUDA         = CommandNamedArg(Pattern(\"v|verbose\"), \"Toggle verbose output.\")\nAction      = default_\nGroup       = CommandArgGroup(\"\", \"\")\nExistence   = optional\nParseScheme = bool_\n\n[Argument Info - ArgumentInfo!(CommandNamedArg, MyCommand)]\nIdentifier  = lCount\nUDA         = CommandNamedArg(Pattern(\"l\"), \"Verbose level counter.\")\nAction      = count\nGroup       = CommandArgGroup(\"\", \"\")\nExistence   = cast(CommandArgExistence)3 # NOTE: 3 = multiple | optional, result of the `count` action\nParseScheme = allowRepeatedName          # Result of the `count` action\n\n[Argument Info - ArgumentInfo!(CommandPositionalArg, MyCommand)]\nIdentifier  = arg1\nUDA         = CommandPositionalArg(0, \"arg1\", \"The first argument to do stuff with.\")\nAction      = default_\nGroup       = CommandArgGroup(\"\", \"\")\nExistence   = default_\nParseScheme = default_\n\n[No Raw Arg List]\n\nArg0Nullable = true\n```\n\nI'll also note that every `ArgumentInfo` also contains an `actionFunc` variable which will be one of the functions inside of\n`jaster.cli.infogen.actions`. This function will perform the binding action (e.g. default_ goes through the `ArgBinder`, count increments, etc.).\n\n## Light-weight command parsing\n\nSome users may find `CommandLineInterface` too *forceful* and heavy in how it works. Some users may prefer that JCLI only handle\nargument parsing and value binding, and then these users will handle the execution/logic themselves.\n\nTo do this, you can use the `CommandParser` struct, which is responsible for only parsing data into a command instance. It doesn't even know\nhow to construct a command, so you'll have to do that yourself beforehand.\n\nHere's an example:\n\n```d\nimport std, jaster.cli;\nenum CalculateOperation\n{\n    add,\n    sub\n}\n\n@CommandDefault // CommandParser doesn't really care about this UDA, it just wants it to exist (or @Command)\nstruct CalculateCommand\n{\n    @CommandPositionalArg(0, \"a\", \"The first value.\")\n    int a;\n\n    @CommandPositionalArg(1, \"b\", \"The second value.\")\n    int b;\n\n    @CommandNamedArg(\"o|op\", \"The operation to perform.\")\n    CalculateOperation op;\n}\n\nint main(string[] args)\n{\n    // If you don't specify an `ArgBinder`, then `CommandParser` will use the default one.\n    CommandParser!(CalculateCommand, ArgBinder!()) parser; // Same as: CommandParser!CalculateCommand\n\n    CalculateCommand instance;\n    Result!void result = parser.parse(args[1..$], /*ref*/ instance); // args[0] is the program name, so we need to skip it.\n\n    // Normally CommandLineInterface handles everything for us, but now we have to do this ourselves.\n    if(!result.isSuccess)\n    {\n        writeln(\"calculate: \", result.asFailure.error);\n        return -1;\n    }\n\n    // We also have to call/handle command logic ourself.\n    final switch(instance.op) with(CalculateOperation)\n    {\n        case add: writeln(instance.a + instance.b); break;\n        case sub: writeln(instance.a - instance.b); break;\n    }\n\n    return 0;\n}\n```\n\nIf you're this far down you won't need any example output of the above, so I've not bothered with it.\n\nThis usage of JCLI supports all forms of argument parsing and value binding (validators, custom binders, etc.) but does not support:\n    * Help text generation (see: [Light-weight command help text](#light-weight-command-help-text))\n    * Dependency Injection\n    * Automatic support for multiple commands (you'll have to build that yourself on top of `CommandParser`)\n    * Bash Completion (planned to become an independent component though)\n    * Basically anything other than parsing arguments.\n\n## Light-weight command help text\n\nIn situations where you'd rather use light-weight command parsing instead of `CommandLineInterface`, chances are that you'd also like easy access\nto JCLI's per-command help text generation.\n\nThis can be achieved using the `CommandHelpText` struct which can be used to either generate a `HelpTextBuilderSimple`, or just a plain `string`\nin the exact same format that you'd normally get by using `CommandLineInterface`:\n\n```d\nmodule app;\nimport std, jaster.cli;\n\n@Command(\"command\", \"This is a command that is totally super complicated.\")\nstruct ComplexCommand\n{\n    @CommandPositionalArg(0, \"arg1\", \"This is a generic argument that isn't grouped anywhere\")\n    int a;\n    @CommandPositionalArg(1, \"arg2\", \"This is a generic argument that isn't grouped anywhere\")\n    int b;\n\n    @CommandNamedArg(\"test-flag\", \"Test flag, please ignore.\")\n    bool flag;\n\n    @CommandArgGroup(\"Debug\", \"Arguments related to debugging.\")\n    {\n        @CommandNamedArg(\"verbose|v\", \"Enables verbose logging.\")\n        Nullable!bool verbose;\n\n        @CommandNamedArg(\"log|l\", \"Specifies a log file to direct output to.\")\n        Nullable!string log;\n    }\n\n    @CommandArgGroup(\"I/O\", \"Arguments related to I/O.\")\n    {\n        @CommandPositionalArg(2, \"output\", \"Where to place the output.\")\n        string output;\n\n        @CommandNamedArg(\"config|c\", \"Specifies the config file to use.\")\n        Nullable!string config;\n    }\n\n    void onExecute(){}\n}\n\nvoid main(string[] args)\n{\n    CommandHelpText!ComplexCommand helpText;\n    writeln(helpText.toString(\"mytool.exe\"));\n}\n```\n\nThis is almost exactly the same as the [argument groups](#argument-groups) example, except that instead of going through `CommandLineInterface` we use `CommandHelpText`\nto directly access the help text for our `ComplexCommand`.\n\nThe output is exactly the same as shown in the [argument groups](#argument-groups) example, so I won't be duplicating it here.\n\n# Using a custom sink in CommandLineInterface\n\nBy default `CommandLineInterface` will always output onto stdout. This can be undesirable in certain cases, so `CommandLineInterface` allows you\nto specify your own sink to output to.\n\nPlease note however that this sink will only affect `CommandLineInterface` itself. Commands may use whatever I/O they desire, so it's unreasonable\nto expect this sink to carry over to commands.\n\nTo set this sink you must set the `CommandLineSettings.sink` value when passing in an instance of `CommandLineSettings` into your `CommandLineInterface`:\n\n```d\nmodule app;\nimport std, jaster.cli;\n\n@Command(\"dummy\", \"This is a dummy command\")\nstruct DummyCommand\n{\n    void onExecute(){}\n}\n\nvoid main()\n{\n    string log;\n\n    CommandLineSettings settings;\n    settings.sink = (string str) { log ~= str; };\n\n    auto cli = new CommandLineInterface!app(settings);\n    cli.parseAndExecute([\"--help\"], IgnoreFirstArg.no);\n\n    assert(log.length > 0);\n    assert(log.canFind(\"dummy\"));\n}\n```\n\nThe above example shows a minimal program that captures the output of `CommandLineInterface` into a string.\n\nIf `CommandLineSettings.sink` is left as null (that is, `Nullable.isNull`, not `is null`) then `CommandLineInterface` will default to using `std.stdio.write`.\n\n# Using JCLI without Dub\n\nIt is entirely possible to use JCLI without needing to use dub, there are just two things to keep in mind.\n\n1. JCLI has a hard dependency on [JIOC](https://github.com/BradleyChatha/jioc), however I am the maintainer of this library, and it is a single-file library, so it is both\nsafe to assume it'll stay up-to-date, and it is easy to add into your project.\n\n2. For optional dependencies that JCLI supports, such as asdf, these are locked behind different [versions](#versions) so you only need to include them if you're using\nthem in the first place.\n\nOther than that, if you're not using dub/dub-compatible build system, then I assume you already understand how you would go about adding third party code into your builds.\n\nFurthermore, you may also make use of the [amalgamation](#using-the-amalgamation) file if needed.\n\n# Using the amalgamation\n\nThe amalgamation [file](https://github.com/BradleyChatha/jcli/blob/master/single-file/jcli.d) is a file with JCLI's source code bundled into a single file, with\na few patches made to ensure that it can compile.\n\nThe existence of this file was inspired by a certain property of the excellent [arsd](https://github.com/adamdruppe/arsd) collection: all you need is a file or two\nand suddenly you have access to some very useful code.\n\nLikewise the idea with the amalgamation file is that all you have to do is copy it into your project and then it's ready to use.\n\nHowever, it's not a clean replacement for using JCLI as a dub package/multi-file library, as there are certain side effects and considerations:\n\n1. JCLI has a hard dependency on JIOC, so JIOC's source code is *also* included inside of the amalgamation.\n\n    * This means if your project already includes JIOC as a dub package, you'll have to remove it and use the amalgamation version otherwise you'll get conflicts.\n\n    * Whether or not you want or need it, you now have JIOC included within your project as well.\n\n    * I may provide another amalgamation file that doesn't include JIOC's source code, but assumes your project will have `import jioc` available.\n\n1. Because all of the code is now inside of a single file, this also means that there is only a single module.\n\n    * So instead of `import jaster.cli, jaster.cli.binder, jcli` and so on, the only thing you can import now is `import jcli`.\n\n    * This means that the module also suffers from pollution, which can be pretty annoying especially in regards to the fact JIOC will be implicitly included as well.\n\n    * D's module system however provides selective imports, so that can aid you in avoiding symbol pollution within your code.\n\n1. Support for this is still in the early stages.\n\n    * Throwing a bunch of files together with a few hacks to make them compile can lead to compiler errors, or worse, behavioural differences.\n\n    * Please file an issue if you encounter any problems that are unique to the amalgamation.\n\nFinally, if the idea of the amalgamation is appealing to you, but you feel there are certain problems or difficulties that can be addressed, feel free to file an issue.\n\n# Versions\n\nJCLI makes use of the `version` statement in various areas. Here is a list of all versions that JCLI utilises.\n\nAny versions prefixed with `Have_` are automatically created by dub for each dependency in your project. For example, `Have_asdf` will be automatically\ndefined by dub if you have `asdf` as a dependency of your project. If you do not use dub then you'll have to manually specify these versions when relevant.\n\n| Version                   | Description                                                                                                                    |\n| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |\n| JCLI_Verbose              | When defined, enables certain verbose compile-time logging, such as how `ArgBinder` is deciding which `@ArgBinderFunc` to use. |\n| Have_asdf                 | Enables the `AsdfConfigAdapter`, which uses the `asdf` library to serialise the configuration value.                           |\n\n# Contributing\n\nI'm perfectly accepting of anyone wanting to contribute to this library, just note that it might take me a while to respond.\n\nAnd please, if you have an issue, *create a Github issue for me*. I can't fix or prioritise issues that I don't know exist.\nI tend to not care about issues when **I** run across them, but when **someone else** runs into them, then it becomes a much higher priority for me to address it.\n\nFinally, if you use JCLI in anyway feel free to request for me to add your project into the `Examples` section. I'd really love to see how others are using my code :)\n",
    "docFolder":"",
    "version":"0.12.0"
 }